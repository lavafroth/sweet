modifier = {
    ^"altgr"
    | ^"alt"
    | ^"control"
    | ^"ctrl"
    | ^"mod1"
    | ^"mod4"
    | ^"mod5"
    | ^"shift"
    | ^"super"
    | ^"any"
}

// TODO: add all valid keys here
keys_always_escaped = _{ "\\~" | "\\@" | "\\+" | "\\\\" }
key_base = { keys_always_escaped | ^"enter" | ^"return" | ASCII_ALPHANUMERIC }

key_attributes = _{ send? ~ on_release? }
key_normal =  { key_attributes ~ (key_base | "," | "-") }
key_in_shorthand = { !shorthand_deny ~ key_attributes ~ (shorthand_allow | key_base) }

send             =  { "~" }
on_release       =  { "@" }
concat           = _{ "+" }
escape_lf        = _{ "\\\n" }
WHITESPACE       = _{ " " | "\t" | escape_lf }
not_newline      = _{ !NEWLINE ~ !escape_lf ~ ANY }
shorthand_bounds =  { "{" | "}" }

shorthand_deny  = { NEWLINE | shorthand_bounds | "," | "-" }
shorthand_allow = { "\\," | "\\{" | "\\}" | "\\-" }

key_range    =  { key_in_shorthand ~ "-" ~ key_in_shorthand }
key_or_range = _{ key_range | key_in_shorthand }

shorthand = {
    "{" ~ ((key_in_shorthand ~ "," ~ key_or_range) | key_range) ~ ("," ~ key_or_range)* ~ "}"
}

// no dashes accepted, no dashes needed
// one would not expect the range "super-alt" to work anyway.
modifier_shorthand    =  { "{" ~ (modifier ~ ",")+ ~ modifier ~ "}" }

omission                =  { "_" }
modifier_omit           = _{ omission | (modifier ~ concat) }
modifier_omit_shorthand =  { "{" ~ modifier_omit ~ ("," ~ modifier_omit)+ ~ "}" }
modifier_or_shorthand                = _{ (modifier | modifier_shorthand) ~ concat }

comment = _{ WHITESPACE* ~ "#" ~ not_newline* }

command_composite     = _{ !shorthand_deny ~ (shorthand_allow | ANY) }
command_component     =  { command_composite+ }
visible_composite     =  { command_composite }
range                 =  { visible_composite ~ WHITESPACE* ~ "-" ~ WHITESPACE* ~ visible_composite }
command_component_and = _{ WHITESPACE* ~ "," ~ WHITESPACE* ~ (range | command_component) }

inside_braces      = _{ (command_component ~ command_component_and+) | (range ~ command_component_and*) }
command_shorthand =  { "{" ~ inside_braces ~ "}" }

// make sure that a standalone part of a command does not overlap with
// parts inside braces
command_standalone = { (!shorthand_bounds ~ not_newline)+ }

command_line = _{ (command_shorthand | command_standalone)* }

// We use a WHITESPACE+ in the trailing matcher to automatically trim whitespaces (and tabs) from
// multiline commands. ---------------------------------------------v
command = ${ NEWLINE ~ WHITESPACE+ ~ command_line ~ (escape_lf ~ WHITESPACE+ ~ command_line)* }
// For example
//
// hello \
//      world
//
// becomes "hello world"
//
// The dollar sign makes this atomic, this statement as well as anything
// inside it must explicitly specify newlines and whitespaces.

trigger = _{ (modifier_or_shorthand | modifier_omit_shorthand)* ~ (key_normal | shorthand) }

maybe_some_lines_of_comments = { (NEWLINE ~ comment)* }

binding = {
    trigger ~ comment?
    ~ maybe_some_lines_of_comments
    ~ command
}

unbind = { "ignore" ~ trigger }

import_file = { (!NEWLINE ~ ANY)+ }
import      = { "include" ~ import_file }

oneoff              =  { "oneoff" }
swallow             =  { "swallow" }
modename_characters = _{ !NEWLINE ~ !(oneoff | swallow) ~ ANY }
modename            =  { modename_characters+ }
primitives          = _{ comment | unbind | binding }

mode = { "mode" ~ modename ~ oneoff? ~ swallow? ~ comment? ~ NEWLINE ~ WHITESPACE* ~ (primitives ~ NEWLINE)+ ~ "endmode" }

content = _{ comment | mode | unbind | binding | import | NEWLINE }

main = {
    SOI ~ content* ~ EOI
}
